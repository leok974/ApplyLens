"""
Weekly Intelligence Report Generator.

Generates comprehensive markdown reports on agent quality:
- Quality trends (week-over-week)
- Budget violations
- Invariant status
- Red-team results
- Top issues and recommendations

Reports can be:
- Posted to Slack
- Emailed to team
- Saved as markdown files
- Viewed in web UI
"""

from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from sqlalchemy.orm import Session
from ..models import AgentMetricsDaily
from .budgets import GateEvaluator, DEFAULT_BUDGETS
from .telemetry import MetricsAggregator, RedTeamCatalog


class ReportGenerator:
    """Generates weekly intelligence reports on agent quality."""

    def __init__(self, db: Session):
        self.db = db
        self.gate_evaluator = GateEvaluator(db)
        self.metrics_aggregator = MetricsAggregator(db)

    def generate_weekly_report(
        self,
        week_start: Optional[datetime] = None,
        include_charts: bool = False,
    ) -> str:
        """
        Generate comprehensive weekly intelligence report.

        Args:
            week_start: Start of week (Monday). Defaults to last Monday.
            include_charts: Include ASCII charts (default: False)

        Returns:
            Markdown formatted report
        """
        if week_start is None:
            # Default to last Monday
            today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
            week_start = today - timedelta(days=today.weekday())

        week_start + timedelta(days=7)
        prev_week_start = week_start - timedelta(days=7)

        # Gather data
        gate_results = self.gate_evaluator.evaluate_all_agents(
            lookback_days=7,
            baseline_days=7,
        )

        # Build report
        lines = []

        # Header
        lines.append("# ðŸŽ¯ Agent Intelligence Report")
        lines.append(f"\n**Week of {week_start.strftime('%B %d, %Y')}**")
        lines.append(
            f"\nGenerated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}\n"
        )

        # Executive Summary
        lines.append("## ðŸ“Š Executive Summary\n")
        lines.extend(self._generate_summary(gate_results))

        # Per-Agent Analysis
        lines.append("\n## ðŸ¤– Agent Analysis\n")
        for agent in sorted(DEFAULT_BUDGETS.keys()):
            if agent in gate_results["results"]:
                lines.extend(
                    self._generate_agent_section(
                        agent,
                        gate_results["results"][agent],
                        week_start,
                        prev_week_start,
                    )
                )

        # Budget Violations
        if gate_results["total_violations"] > 0:
            lines.append("\n## âš ï¸ Budget Violations\n")
            lines.extend(self._generate_violations_section(gate_results))

        # Invariant Status
        lines.append("\n## âœ… Invariant Status\n")
        lines.extend(self._generate_invariants_section(week_start))

        # Red Team Results
        lines.append("\n## ðŸ”´ Red Team Testing\n")
        lines.extend(self._generate_redteam_section(week_start))

        # Recommendations
        lines.append("\n## ðŸ’¡ Recommendations\n")
        lines.extend(self._generate_recommendations(gate_results))

        # Footer
        lines.append("\n---")
        lines.append("\n*Report generated by ApplyLens Agent Evaluation System*")

        return "\n".join(lines)

    def _generate_summary(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate executive summary section."""
        lines = []

        total_agents = len(gate_results["results"])
        passing_agents = sum(1 for r in gate_results["results"].values() if r["passed"])
        failing_agents = total_agents - passing_agents

        # Overall status
        if gate_results["passed"]:
            status_icon = "âœ…"
            status_text = "All systems operational"
        elif gate_results["critical_violations"] > 0:
            status_icon = "ðŸ”´"
            status_text = "Critical issues detected"
        else:
            status_icon = "âš ï¸"
            status_text = "Warnings present"

        lines.append(f"**Status:** {status_icon} {status_text}\n")

        # Quick stats
        lines.append(f"- **Agents Monitored:** {total_agents}")
        lines.append(f"- **Passing Quality Gates:** {passing_agents}/{total_agents}")
        if failing_agents > 0:
            lines.append(f"- **Failing Quality Gates:** {failing_agents}")
        lines.append(f"- **Total Violations:** {gate_results['total_violations']}")
        if gate_results["critical_violations"] > 0:
            lines.append(
                f"- **Critical Violations:** {gate_results['critical_violations']}"
            )

        return lines

    def _generate_agent_section(
        self,
        agent: str,
        result: Dict[str, Any],
        week_start: datetime,
        prev_week_start: datetime,
    ) -> List[str]:
        """Generate per-agent analysis section."""
        lines = []

        lines.append(f"### {agent}")

        # Status
        if result["passed"]:
            lines.append("**Status:** âœ… Passing all quality gates")
        else:
            lines.append(f"**Status:** âŒ {len(result['violations'])} violation(s)")

        # Current metrics
        current = result.get("current_metrics", {})
        if current:
            lines.append("\n**Current Week Performance:**")
            if current.get("avg_quality_score"):
                lines.append(f"- Quality Score: {current['avg_quality_score']:.1f}/100")
            if current.get("success_rate"):
                lines.append(f"- Success Rate: {current['success_rate']:.1%}")
            if current.get("avg_latency_ms"):
                lines.append(f"- Avg Latency: {current['avg_latency_ms']:.0f}ms")
            if current.get("total_runs"):
                lines.append(f"- Total Runs: {current['total_runs']}")

        # Week-over-week comparison
        baseline = result.get("baseline_metrics", {})
        if current and baseline:
            lines.append("\n**Week-over-Week Change:**")

            if current.get("avg_quality_score") and baseline.get("avg_quality_score"):
                quality_change = (
                    current["avg_quality_score"] - baseline["avg_quality_score"]
                )
                icon = (
                    "ðŸ“ˆ" if quality_change > 0 else "ðŸ“‰" if quality_change < 0 else "âž¡ï¸"
                )
                lines.append(f"- Quality: {icon} {quality_change:+.1f} points")

            if current.get("avg_latency_ms") and baseline.get("avg_latency_ms"):
                latency_change_pct = (
                    (current["avg_latency_ms"] - baseline["avg_latency_ms"])
                    / baseline["avg_latency_ms"]
                ) * 100
                icon = (
                    "ðŸŒ"
                    if latency_change_pct > 10
                    else "âš¡"
                    if latency_change_pct < -10
                    else "âž¡ï¸"
                )
                lines.append(f"- Latency: {icon} {latency_change_pct:+.1f}%")

        # Violations
        if result["violations"]:
            lines.append("\n**Issues:**")
            for v in result["violations"]:
                severity_icon = "ðŸ”´" if v.severity == "critical" else "âš ï¸"
                lines.append(f"- {severity_icon} {v.message}")

        lines.append("")  # Blank line between agents

        return lines

    def _generate_violations_section(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate budget violations section."""
        lines = []

        # Group violations by severity
        critical = []
        errors = []
        warnings = []

        for agent_result in gate_results["results"].values():
            for v in agent_result["violations"]:
                if v.severity == "critical":
                    critical.append((v.agent, v))
                elif v.severity == "error":
                    errors.append((v.agent, v))
                else:
                    warnings.append((v.agent, v))

        if critical:
            lines.append("### ðŸ”´ Critical")
            for agent, v in critical:
                lines.append(f"- **{agent}**: {v.message}")
            lines.append("")

        if errors:
            lines.append("### âš ï¸ Errors")
            for agent, v in errors:
                lines.append(f"- **{agent}**: {v.message}")
            lines.append("")

        if warnings:
            lines.append("### â„¹ï¸ Warnings")
            for agent, v in warnings:
                lines.append(f"- **{agent}**: {v.message}")

        return lines

    def _generate_invariants_section(self, week_start: datetime) -> List[str]:
        """Generate invariant status section."""
        lines = []

        week_end = week_start + timedelta(days=7)

        # Get invariant pass/fail counts for the week
        metrics = (
            self.db.query(AgentMetricsDaily)
            .filter(
                AgentMetricsDaily.date >= week_start,
                AgentMetricsDaily.date < week_end,
            )
            .all()
        )

        total_passed = sum(m.invariants_passed for m in metrics if m.invariants_passed)
        total_failed = sum(m.invariants_failed for m in metrics if m.invariants_failed)
        total_checks = total_passed + total_failed

        if total_checks > 0:
            pass_rate = total_passed / total_checks
            lines.append(
                f"**Overall Pass Rate:** {pass_rate:.1%} ({total_passed}/{total_checks} checks)"
            )
            lines.append("")

        # List failed invariants
        failed_invariants = set()
        for m in metrics:
            if m.failed_invariant_ids:
                failed_invariants.update(m.failed_invariant_ids)

        if failed_invariants:
            lines.append("**Failed Invariants This Week:**")
            for inv_id in sorted(failed_invariants):
                lines.append(f"- `{inv_id}`")
        else:
            lines.append("âœ… All invariants passing this week")

        return lines

    def _generate_redteam_section(self, week_start: datetime) -> List[str]:
        """Generate red team testing section."""
        lines = []

        week_end = week_start + timedelta(days=7)

        # Get red team metrics
        metrics = (
            self.db.query(AgentMetricsDaily)
            .filter(
                AgentMetricsDaily.date >= week_start,
                AgentMetricsDaily.date < week_end,
            )
            .all()
        )

        total_attacks = sum(
            (m.redteam_attacks_detected or 0)
            + (m.redteam_attacks_missed or 0)
            + (m.redteam_false_positives or 0)
            for m in metrics
        )

        if total_attacks == 0:
            lines.append("No red team attacks executed this week.")
            return lines

        detected = sum(m.redteam_attacks_detected or 0 for m in metrics)
        missed = sum(m.redteam_attacks_missed or 0 for m in metrics)
        false_positives = sum(m.redteam_false_positives or 0 for m in metrics)

        detection_rate = (
            detected / (detected + missed) if (detected + missed) > 0 else 0
        )

        lines.append(f"**Detection Rate:** {detection_rate:.1%}")
        lines.append(f"- Attacks Detected: {detected}")
        lines.append(f"- Attacks Missed: {missed}")
        lines.append(f"- False Positives: {false_positives}")

        # Available attack types
        catalog = RedTeamCatalog()
        lines.append(
            f"\n**Available Attack Types:** {len(catalog.get_all_redteam_tasks())}"
        )

        return lines

    def _generate_recommendations(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations."""
        lines = []
        recommendations = []

        # Analyze violations and generate recommendations
        for agent, result in gate_results["results"].items():
            if not result["passed"]:
                for v in result["violations"]:
                    if v.budget_type == "quality":
                        recommendations.append(
                            f"ðŸ”§ **{agent}**: Quality score below threshold. "
                            "Review recent changes, check golden task performance."
                        )
                    elif v.budget_type == "latency_avg":
                        recommendations.append(
                            f"âš¡ **{agent}**: High latency detected. "
                            "Profile execution, consider caching or optimization."
                        )
                    elif v.budget_type == "success_rate":
                        recommendations.append(
                            f"ðŸ› **{agent}**: Low success rate. "
                            "Check error logs, review exception handling."
                        )
                    elif v.budget_type == "invariants":
                        recommendations.append(
                            f"ðŸš¨ **{agent}**: Invariant violations. "
                            "Critical regression detected - investigate immediately."
                        )
                    elif v.budget_type in ("quality_regression", "latency_regression"):
                        recommendations.append(
                            f"ðŸ“‰ **{agent}**: Performance regression. "
                            "Compare with baseline, revert recent changes if needed."
                        )

        # Deduplicate and limit
        recommendations = list(dict.fromkeys(recommendations))[:10]

        if recommendations:
            for rec in recommendations:
                lines.append(f"- {rec}")
        else:
            lines.append("âœ… No action items - all agents performing within budgets")

        return lines


def generate_report_cli(
    db: Session,
    output_file: Optional[str] = None,
    slack_webhook: Optional[str] = None,
) -> str:
    """
    Generate report from CLI.

    Args:
        db: Database session
        output_file: Optional file path to save report
        slack_webhook: Optional Slack webhook URL to post report

    Returns:
        Generated report text
    """
    generator = ReportGenerator(db)
    report = generator.generate_weekly_report()

    # Save to file
    if output_file:
        with open(output_file, "w") as f:
            f.write(report)
        print(f"Report saved to {output_file}")

    # Post to Slack
    if slack_webhook:
        try:
            import requests

            response = requests.post(
                slack_webhook,
                json={"text": report},
                timeout=10,
            )
            if response.status_code == 200:
                print("Report posted to Slack")
            else:
                print(f"Failed to post to Slack: {response.status_code}")
        except Exception as e:
            print(f"Error posting to Slack: {e}")

    return report


def format_report_as_html(markdown_report: str) -> str:
    """
    Convert markdown report to HTML.

    Args:
        markdown_report: Markdown formatted report

    Returns:
        HTML formatted report
    """
    try:
        import markdown

        return markdown.markdown(markdown_report, extensions=["tables", "fenced_code"])
    except ImportError:
        # Fallback: simple HTML wrapping
        return f"<pre>{markdown_report}</pre>"
