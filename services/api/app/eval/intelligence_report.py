"""
Weekly Intelligence Report Generator.

Generates comprehensive markdown reports on agent quality:
- Quality trends (week-over-week)
- Budget violations
- Invariant status
- Red-team results
- Top issues and recommendations

Reports can be:
- Posted to Slack
- Emailed to team
- Saved as markdown files
- Viewed in web UI
"""
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func, desc
from ..models import AgentMetricsDaily
from .budgets import GateEvaluator, Budget, DEFAULT_BUDGETS
from .telemetry import MetricsAggregator, RedTeamCatalog
from .runner import EvalRunner


class ReportGenerator:
    """Generates weekly intelligence reports on agent quality."""
    
    def __init__(self, db: Session):
        self.db = db
        self.gate_evaluator = GateEvaluator(db)
        self.metrics_aggregator = MetricsAggregator(db)
    
    def generate_weekly_report(
        self,
        week_start: Optional[datetime] = None,
        include_charts: bool = False,
    ) -> str:
        """
        Generate comprehensive weekly intelligence report.
        
        Args:
            week_start: Start of week (Monday). Defaults to last Monday.
            include_charts: Include ASCII charts (default: False)
            
        Returns:
            Markdown formatted report
        """
        if week_start is None:
            # Default to last Monday
            today = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
            week_start = today - timedelta(days=today.weekday())
        
        week_end = week_start + timedelta(days=7)
        prev_week_start = week_start - timedelta(days=7)
        
        # Gather data
        gate_results = self.gate_evaluator.evaluate_all_agents(
            lookback_days=7,
            baseline_days=7,
        )
        
        # Build report
        lines = []
        
        # Header
        lines.append("# 🎯 Agent Intelligence Report")
        lines.append(f"\n**Week of {week_start.strftime('%B %d, %Y')}**")
        lines.append(f"\nGenerated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}\n")
        
        # Executive Summary
        lines.append("## 📊 Executive Summary\n")
        lines.extend(self._generate_summary(gate_results))
        
        # Per-Agent Analysis
        lines.append("\n## 🤖 Agent Analysis\n")
        for agent in sorted(DEFAULT_BUDGETS.keys()):
            if agent in gate_results["results"]:
                lines.extend(self._generate_agent_section(
                    agent,
                    gate_results["results"][agent],
                    week_start,
                    prev_week_start,
                ))
        
        # Budget Violations
        if gate_results["total_violations"] > 0:
            lines.append("\n## ⚠️ Budget Violations\n")
            lines.extend(self._generate_violations_section(gate_results))
        
        # Invariant Status
        lines.append("\n## ✅ Invariant Status\n")
        lines.extend(self._generate_invariants_section(week_start))
        
        # Red Team Results
        lines.append("\n## 🔴 Red Team Testing\n")
        lines.extend(self._generate_redteam_section(week_start))
        
        # Recommendations
        lines.append("\n## 💡 Recommendations\n")
        lines.extend(self._generate_recommendations(gate_results))
        
        # Footer
        lines.append("\n---")
        lines.append("\n*Report generated by ApplyLens Agent Evaluation System*")
        
        return "\n".join(lines)
    
    def _generate_summary(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate executive summary section."""
        lines = []
        
        total_agents = len(gate_results["results"])
        passing_agents = sum(
            1 for r in gate_results["results"].values() if r["passed"]
        )
        failing_agents = total_agents - passing_agents
        
        # Overall status
        if gate_results["passed"]:
            status_icon = "✅"
            status_text = "All systems operational"
        elif gate_results["critical_violations"] > 0:
            status_icon = "🔴"
            status_text = "Critical issues detected"
        else:
            status_icon = "⚠️"
            status_text = "Warnings present"
        
        lines.append(f"**Status:** {status_icon} {status_text}\n")
        
        # Quick stats
        lines.append(f"- **Agents Monitored:** {total_agents}")
        lines.append(f"- **Passing Quality Gates:** {passing_agents}/{total_agents}")
        if failing_agents > 0:
            lines.append(f"- **Failing Quality Gates:** {failing_agents}")
        lines.append(f"- **Total Violations:** {gate_results['total_violations']}")
        if gate_results["critical_violations"] > 0:
            lines.append(f"- **Critical Violations:** {gate_results['critical_violations']}")
        
        return lines
    
    def _generate_agent_section(
        self,
        agent: str,
        result: Dict[str, Any],
        week_start: datetime,
        prev_week_start: datetime,
    ) -> List[str]:
        """Generate per-agent analysis section."""
        lines = []
        
        lines.append(f"### {agent}")
        
        # Status
        if result["passed"]:
            lines.append("**Status:** ✅ Passing all quality gates")
        else:
            lines.append(f"**Status:** ❌ {len(result['violations'])} violation(s)")
        
        # Current metrics
        current = result.get("current_metrics", {})
        if current:
            lines.append("\n**Current Week Performance:**")
            if current.get("avg_quality_score"):
                lines.append(f"- Quality Score: {current['avg_quality_score']:.1f}/100")
            if current.get("success_rate"):
                lines.append(f"- Success Rate: {current['success_rate']:.1%}")
            if current.get("avg_latency_ms"):
                lines.append(f"- Avg Latency: {current['avg_latency_ms']:.0f}ms")
            if current.get("total_runs"):
                lines.append(f"- Total Runs: {current['total_runs']}")
        
        # Week-over-week comparison
        baseline = result.get("baseline_metrics", {})
        if current and baseline:
            lines.append("\n**Week-over-Week Change:**")
            
            if current.get("avg_quality_score") and baseline.get("avg_quality_score"):
                quality_change = current["avg_quality_score"] - baseline["avg_quality_score"]
                icon = "📈" if quality_change > 0 else "📉" if quality_change < 0 else "➡️"
                lines.append(f"- Quality: {icon} {quality_change:+.1f} points")
            
            if current.get("avg_latency_ms") and baseline.get("avg_latency_ms"):
                latency_change_pct = ((current["avg_latency_ms"] - baseline["avg_latency_ms"]) 
                                     / baseline["avg_latency_ms"]) * 100
                icon = "🐌" if latency_change_pct > 10 else "⚡" if latency_change_pct < -10 else "➡️"
                lines.append(f"- Latency: {icon} {latency_change_pct:+.1f}%")
        
        # Violations
        if result["violations"]:
            lines.append("\n**Issues:**")
            for v in result["violations"]:
                severity_icon = "🔴" if v.severity == "critical" else "⚠️"
                lines.append(f"- {severity_icon} {v.message}")
        
        lines.append("")  # Blank line between agents
        
        return lines
    
    def _generate_violations_section(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate budget violations section."""
        lines = []
        
        # Group violations by severity
        critical = []
        errors = []
        warnings = []
        
        for agent_result in gate_results["results"].values():
            for v in agent_result["violations"]:
                if v.severity == "critical":
                    critical.append((v.agent, v))
                elif v.severity == "error":
                    errors.append((v.agent, v))
                else:
                    warnings.append((v.agent, v))
        
        if critical:
            lines.append("### 🔴 Critical")
            for agent, v in critical:
                lines.append(f"- **{agent}**: {v.message}")
            lines.append("")
        
        if errors:
            lines.append("### ⚠️ Errors")
            for agent, v in errors:
                lines.append(f"- **{agent}**: {v.message}")
            lines.append("")
        
        if warnings:
            lines.append("### ℹ️ Warnings")
            for agent, v in warnings:
                lines.append(f"- **{agent}**: {v.message}")
        
        return lines
    
    def _generate_invariants_section(self, week_start: datetime) -> List[str]:
        """Generate invariant status section."""
        lines = []
        
        week_end = week_start + timedelta(days=7)
        
        # Get invariant pass/fail counts for the week
        metrics = self.db.query(AgentMetricsDaily).filter(
            AgentMetricsDaily.date >= week_start,
            AgentMetricsDaily.date < week_end,
        ).all()
        
        total_passed = sum(m.invariants_passed for m in metrics if m.invariants_passed)
        total_failed = sum(m.invariants_failed for m in metrics if m.invariants_failed)
        total_checks = total_passed + total_failed
        
        if total_checks > 0:
            pass_rate = total_passed / total_checks
            lines.append(f"**Overall Pass Rate:** {pass_rate:.1%} ({total_passed}/{total_checks} checks)")
            lines.append("")
        
        # List failed invariants
        failed_invariants = set()
        for m in metrics:
            if m.failed_invariant_ids:
                failed_invariants.update(m.failed_invariant_ids)
        
        if failed_invariants:
            lines.append("**Failed Invariants This Week:**")
            for inv_id in sorted(failed_invariants):
                lines.append(f"- `{inv_id}`")
        else:
            lines.append("✅ All invariants passing this week")
        
        return lines
    
    def _generate_redteam_section(self, week_start: datetime) -> List[str]:
        """Generate red team testing section."""
        lines = []
        
        week_end = week_start + timedelta(days=7)
        
        # Get red team metrics
        metrics = self.db.query(AgentMetricsDaily).filter(
            AgentMetricsDaily.date >= week_start,
            AgentMetricsDaily.date < week_end,
        ).all()
        
        total_attacks = sum(
            (m.redteam_attacks_detected or 0) + 
            (m.redteam_attacks_missed or 0) + 
            (m.redteam_false_positives or 0)
            for m in metrics
        )
        
        if total_attacks == 0:
            lines.append("No red team attacks executed this week.")
            return lines
        
        detected = sum(m.redteam_attacks_detected or 0 for m in metrics)
        missed = sum(m.redteam_attacks_missed or 0 for m in metrics)
        false_positives = sum(m.redteam_false_positives or 0 for m in metrics)
        
        detection_rate = detected / (detected + missed) if (detected + missed) > 0 else 0
        
        lines.append(f"**Detection Rate:** {detection_rate:.1%}")
        lines.append(f"- Attacks Detected: {detected}")
        lines.append(f"- Attacks Missed: {missed}")
        lines.append(f"- False Positives: {false_positives}")
        
        # Available attack types
        catalog = RedTeamCatalog()
        lines.append(f"\n**Available Attack Types:** {len(catalog.get_all_redteam_tasks())}")
        
        return lines
    
    def _generate_recommendations(self, gate_results: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations."""
        lines = []
        recommendations = []
        
        # Analyze violations and generate recommendations
        for agent, result in gate_results["results"].items():
            if not result["passed"]:
                for v in result["violations"]:
                    if v.budget_type == "quality":
                        recommendations.append(
                            f"🔧 **{agent}**: Quality score below threshold. "
                            "Review recent changes, check golden task performance."
                        )
                    elif v.budget_type == "latency_avg":
                        recommendations.append(
                            f"⚡ **{agent}**: High latency detected. "
                            "Profile execution, consider caching or optimization."
                        )
                    elif v.budget_type == "success_rate":
                        recommendations.append(
                            f"🐛 **{agent}**: Low success rate. "
                            "Check error logs, review exception handling."
                        )
                    elif v.budget_type == "invariants":
                        recommendations.append(
                            f"🚨 **{agent}**: Invariant violations. "
                            "Critical regression detected - investigate immediately."
                        )
                    elif v.budget_type in ("quality_regression", "latency_regression"):
                        recommendations.append(
                            f"📉 **{agent}**: Performance regression. "
                            "Compare with baseline, revert recent changes if needed."
                        )
        
        # Deduplicate and limit
        recommendations = list(dict.fromkeys(recommendations))[:10]
        
        if recommendations:
            for rec in recommendations:
                lines.append(f"- {rec}")
        else:
            lines.append("✅ No action items - all agents performing within budgets")
        
        return lines


def generate_report_cli(
    db: Session,
    output_file: Optional[str] = None,
    slack_webhook: Optional[str] = None,
) -> str:
    """
    Generate report from CLI.
    
    Args:
        db: Database session
        output_file: Optional file path to save report
        slack_webhook: Optional Slack webhook URL to post report
        
    Returns:
        Generated report text
    """
    generator = ReportGenerator(db)
    report = generator.generate_weekly_report()
    
    # Save to file
    if output_file:
        with open(output_file, "w") as f:
            f.write(report)
        print(f"Report saved to {output_file}")
    
    # Post to Slack
    if slack_webhook:
        try:
            import requests
            response = requests.post(
                slack_webhook,
                json={"text": report},
                timeout=10,
            )
            if response.status_code == 200:
                print("Report posted to Slack")
            else:
                print(f"Failed to post to Slack: {response.status_code}")
        except Exception as e:
            print(f"Error posting to Slack: {e}")
    
    return report


def format_report_as_html(markdown_report: str) -> str:
    """
    Convert markdown report to HTML.
    
    Args:
        markdown_report: Markdown formatted report
        
    Returns:
        HTML formatted report
    """
    try:
        import markdown
        return markdown.markdown(markdown_report, extensions=["tables", "fenced_code"])
    except ImportError:
        # Fallback: simple HTML wrapping
        return f"<pre>{markdown_report}</pre>"
