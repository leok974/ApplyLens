{
  "description": "ApplyLens emails normalization v3 (phishing/risk flags + agentic suggestions)",
  "processors": [
    {
      "pipeline": {
        "name": "applylens_emails_v2",
        "ignore_failure": true
      }
    },
    {
      "script": {
        "lang": "painless",
        "params": {
          "trusted_domains": [
            "prometric.com",
            "finetunelearning.com"
          ],
          "risky_phrases": [
            "mini home office",
            "equipment will be provided",
            "send your details",
            "reply with your name phone location",
            "screening test will be emailed",
            "executive team will assign",
            "work from anywhere",
            "flexible hours",
            "gift card",
            "crypto",
            "zelle",
            "wire",
            "cash app"
          ],
          "request_pii": [
            "ssn",
            "social security",
            "bank",
            "routing",
            "driver's license",
            "id front back",
            "passport",
            "tax",
            "w4"
          ],
          "score_weights": {
            "domain_mismatch": 25,
            "non_canonical_domain": 25,
            "risky_phrase": 10,
            "request_pii": 20,
            "vague_role": 10,
            "no_calendar_invite": 5,
            "no_career_link": 10
          },
          "score_threshold": 40
        },
        "source": "def reasons = new ArrayList();\\ndef actions = new ArrayList();\\ndef checks  = new ArrayList();\\nint score = 0;\\nString subj = (ctx.containsKey('subject') && ctx.subject!=null) ? ctx.subject.toLowerCase() : '';\\nString body = (ctx.containsKey('body_text') && ctx.body_text!=null) ? ctx.body_text.toLowerCase()\\n: (ctx.containsKey('body_html') && ctx.body_html!=null ? ctx.body_html.toLowerCase() : '');\\nString from = (ctx.containsKey('from') && ctx.from!=null) ? ctx.from.toLowerCase() : '';\\n// Extract domain from \"from\"\\nString dom = '';\\nif (from.contains('@')) {\\ntry {\\ndom = from.substring(from.indexOf('@')+1);\\nif (dom.contains('>')) dom = dom.substring(0, dom.indexOf('>'));\\ndom = dom.trim();\\n} catch (Exception e) {}\\n}\\n// Domain mismatch vs brand mentions in body/subject\\ndef mentions_prometric = subj.contains('prometric') || body.contains('prometric');\\ndef mentions_finetune = subj.contains('finetune') || body.contains('finetune');\\ndef brand_mentioned = mentions_prometric || mentions_finetune;\\ndef trusted = false;\\nfor (d in params.trusted_domains) { if (dom.endsWith(d)) { trusted = true; break; } }\\nif (brand_mentioned && dom.length()>0 && !trusted) {\\nscore += params.score_weights.get('domain_mismatch');\\nreasons.add('Sender domain does not match claimed brand: ' + dom);\\nchecks.add('Verify sender domain matches official site (e.g., prometric.com).');\\n}\\nif (dom.length()>0 && !trusted && brand_mentioned) {\\nscore += params.score_weights.get('non_canonical_domain');\\nreasons.add('Non-canonical domain for brand claims: ' + dom);\\nchecks.add('Request a calendar invite from an official corporate domain.');\\n}\\n// Risky phrases\\nint risky_hits = 0;\\nfor (rp in params.risky_phrases) {\\nif (body.contains(rp)) { risky_hits++; }\\n}\\nif (risky_hits>0) {\\nscore += Math.min(3, risky_hits) * params.score_weights.get('risky_phrase');\\nreasons.add('Contains common scam language (' + risky_hits + ' hits).');\\nactions.add('Do not purchase or accept \"equipment\" arrangements or send money.');\\n}\\n// PII request\\nfor (kw in params.request_pii) {\\nif (body.contains(kw)) {\\nscore += params.score_weights.get('request_pii');\\nreasons.add('Requests sensitive personal or financial information.');\\nactions.add('Do not share PII (SSN, banking, IDs) via email.');\\nbreak;\\n}\\n}\\n// Vague role / missing details\\ndef vague = 0;\\nif (!body.contains('salary') && !body.contains('pay') && !body.contains('comp')) vague++;\\nif (!body.contains('manager') && !body.contains('team')) vague++;\\nif (!body.contains('tech stack') && !body.contains('python') && !body.contains('typescript') && !body.contains('c#') && !body.contains('java')) vague++;\\nif (vague>=2) {\\nscore += params.score_weights.get('vague_role');\\nreasons.add('Vague role details (team/tech/comp not specified).');\\n}\\n// No calendar / no careers link hints\\nif (!body.contains('http') && !subj.contains('calendar') && !body.contains('calendar')) {\\nscore += params.score_weights.get('no_calendar_invite');\\nreasons.add('No calendar invite or scheduling link provided.');\\nchecks.add('Ask for an official calendar invite with meeting link.');\\n}\\nif (!body.contains('/careers') && !body.contains('careers.')) {\\nscore += params.score_weights.get('no_career_link');\\nreasons.add('No official careers/job posting link provided.');\\nchecks.add('Request the public job posting on the official careers site.');\\n}\\n// Aggregate \u2192 threshold\\nboolean suspicious = score >= params.score_threshold;\\nctx.suspicion_score = score;\\nctx.suspicious = suspicious;\\n// Explanations + Agent prompts\\nctx.explanations = reasons;\\nif (actions.size()==0) { actions.add('Wait to share any personal details until verified.'); }\\nctx.suggested_actions = actions;\\nif (checks.size()==0) {\\nchecks.add('Verify domain ownership and senders on company website.');\\nchecks.add('Ask for a calendar invite from an official domain.');\\n}\\nctx.verify_checks = checks;\\n// Convenience KQL label\\nif (suspicious) { ctx.labels_norm = (ctx.labels_norm instanceof List ? ctx.labels_norm : new ArrayList()); ctx.labels_norm.add('suspicious'); }"
      }
    },
    {
      "script": {
        "lang": "painless",
        "params": {
          "score_weights": {
            "spf_fail": 10,
            "dkim_fail": 10,
            "dmarc_fail": 15,
            "replyto_mismatch": 15
          }
        },
        "source": "int score = ctx.containsKey('suspicion_score') ? (int)ctx.suspicion_score : 0;\\ndef reasons = ctx.containsKey('explanations') && ctx.explanations instanceof List ? ctx.explanations : new ArrayList();\\ndef checks  = ctx.containsKey('verify_checks') && ctx.verify_checks instanceof List ? ctx.verify_checks : new ArrayList();\\nString auth = (ctx.containsKey('headers_authentication_results') ? ctx.headers_authentication_results : null);\\nString spf  = (ctx.containsKey('headers_received_spf') ? ctx.headers_received_spf : null);\\nString reply = (ctx.containsKey('reply_to') ? ctx.reply_to : null);\\nString from  = (ctx.containsKey('from') ? ctx.from : null);\\ndef has(String s, String p) { return s != null && s.toLowerCase().contains(p); }\\n// SPF\\nif (has(spf, 'fail') || has(auth, 'spf=fail')) {\\nscore += params.score_weights.spf_fail;\\nreasons.add('SPF failed (sender not authorized by domain).');\\nchecks.add('Ask sender to resend from corporate account; verify spf/dmarc on headers.');\\n}\\n// DKIM\\nif (has(auth, 'dkim=fail')) {\\nscore += params.score_weights.dkim_fail;\\nreasons.add('DKIM failed (message integrity not verified).');\\n}\\n// DMARC\\nif (has(auth, 'dmarc=fail') || has(auth, 'policy=reject')) {\\nscore += params.score_weights.dmarc_fail;\\nreasons.add('DMARC failed/policy reject.');\\n}\\n// Reply-To \u2260 From domain\\nString dom = from!=null && from.contains('@') ? from.substring(from.indexOf('@')+1).toLowerCase() : '';\\nString rdom = reply!=null && reply.contains('@') ? reply.substring(reply.indexOf('@')+1).toLowerCase() : '';\\nif (rdom.length()>0 && dom.length()>0 && !rdom.endsWith(dom)) {\\nscore += params.score_weights.replyto_mismatch;\\nreasons.add('Reply-To domain differs from From domain.');\\nchecks.add('Reply only to the address on the official domain after verification.');\\n}\\nctx.suspicion_score = score;\\nif (score >= (ctx.containsKey('score_threshold') ? (int)ctx.score_threshold : 40)) ctx.suspicious = true;\\nctx.explanations = reasons;\\nctx.verify_checks = checks;"
      }
    },
    {
      "script": {
        "lang": "painless",
        "params": {
          "shorteners": [
            "bit.ly",
            "tinyurl.com",
            "t.co",
            "lnkd.in",
            "goo.gl",
            "is.gd",
            "rebrand.ly"
          ],
          "score_weights": {
            "shortener": 8,
            "anchor_mismatch": 12,
            "offbrand_url": 10
          },
          "trusted_brands": [
            "prometric.com",
            "finetunelearning.com",
            "google.com",
            "microsoft.com",
            "zoom.us",
            "teams.microsoft.com"
          ]
        },
        "source": "int score = ctx.containsKey('suspicion_score') ? (int)ctx.suspicion_score : 0;\\ndef reasons = ctx.containsKey('explanations') ? ctx.explanations : new ArrayList();\\ndef checks  = ctx.containsKey('verify_checks') ? ctx.verify_checks : new ArrayList();\\nString html = ctx.containsKey('body_html') && ctx.body_html!=null ? ctx.body_html : '';\\nString text = ctx.containsKey('body_text') && ctx.body_text!=null ? ctx.body_text : '';\\nString blob = (html.length()>0 ? html : text).toLowerCase();\\ndef urls = new ArrayList();\\ndef m;\\n// crude URL regex\\ndef p = /https?:\\\\/\\\\/[\\\\w\\\\-\\\\.]+(?:\\\\:[0-9]+)?[\\\\w\\\\-\\\\./\\\\?\\\\#\\\\&\\\\=\\\\%\\\\+\\\\~]*/;\\nm = p.matcher(blob);\\nwhile (m.find()) { urls.add(m.group()); }\\nboolean shortHit=false, mismatch=false, offbrand=false;\\nfor (u in urls) {\\nfor (s in params.shorteners) { if (u.contains(s)) { shortHit=true; break; } }\\n// Extract host\\nString host = u.replaceFirst('^https?://',''); host = host.contains('/') ? host.substring(0, host.indexOf('/')) : host;\\nif (!html.isEmpty()) {\\n// If anchor text mentions a different brand domain than host, mark mismatch\\nif ((html.contains('>prometric<') || html.contains('>finetune<')) && !(host.endsWith('prometric.com') || host.endsWith('finetunelearning.com'))) { mismatch=true; }\\n}\\nboolean trusted=false;\\nfor (t in params.trusted_brands) { if (host.endsWith(t)) { trusted=true; break; } }\\nif (!trusted) offbrand=true;\\n}\\nif (shortHit) { score += params.score_weights.shortener; reasons.add('Uses link shortener(s).'); checks.add('Hover/expand short links before clicking.'); }\\nif (mismatch) { score += params.score_weights.anchor_mismatch; reasons.add('Anchor text does not match link destination.'); checks.add('Verify destination domain matches displayed brand.'); }\\nif (offbrand && urls.size()>0) { score += params.score_weights.offbrand_url; reasons.add('Links point to non-brand domains.'); }\\nctx.suspicion_score = score;\\nif (score >= (ctx.containsKey('score_threshold') ? (int)ctx.score_threshold : 40)) ctx.suspicious = true;\\nctx.explanations = reasons;\\nctx.verify_checks = checks;"
      }
    },
    {
      "script": {
        "lang": "painless",
        "params": {
          "risky_ext": [
            "exe",
            "msi",
            "js",
            "vbs",
            "ps1",
            "cmd",
            "bat",
            "scr",
            "apk",
            "pkg",
            "docm",
            "xlsm",
            "pptm",
            "zip",
            "rar",
            "7z",
            "iso",
            "img"
          ],
          "score_weights": {
            "risky_attachment": 20
          }
        },
        "source": "if (!ctx.containsKey('attachments')) return;\\nint score = ctx.containsKey('suspicion_score') ? (int)ctx.suspicion_score : 0;\\ndef reasons = ctx.containsKey('explanations') ? ctx.explanations : new ArrayList();\\ndef checks  = ctx.containsKey('verify_checks') ? ctx.verify_checks : new ArrayList();\\nboolean risky=false;\\nfor (att in (List)ctx.attachments) {\\nString name = att.containsKey('filename') && att.filename!=null ? att.filename.toLowerCase() : '';\\nif (name.contains('.')) {\\nString ext = name.substring(name.lastIndexOf('.')+1);\\nfor (rx in params.risky_ext) { if (ext == rx) { risky=true; break; } }\\n}\\n}\\nif (risky) {\\nscore += params.score_weights.risky_attachment;\\nreasons.add('Contains risky attachment type (scripts/executables/macro docs/archives).');\\nchecks.add('Do not open attachments until sender is verified.');\\n}\\nctx.suspicion_score = score;\\nif (score >= (ctx.containsKey('score_threshold') ? (int)ctx.score_threshold : 40)) ctx.suspicious = true;\\nctx.explanations = reasons;\\nctx.verify_checks = checks;"
      }
    },
    {
      "script": {
        "lang": "painless",
        "params": {
          "age_penalty_days": 30,
          "score_weights": {
            "young_domain": 15
          }
        },
        "source": "int score = ctx.containsKey('suspicion_score') ? (int)ctx.suspicion_score : 0;\\ndef reasons = ctx.containsKey('explanations') ? ctx.explanations : new ArrayList();\\nString dom = ctx.containsKey('from_domain') ? ctx.from_domain : null;\\nif (dom == null) {\\nif (ctx.containsKey('from') && ctx.from != null && ctx.from.contains('@')) {\\ndom = ctx.from.substring(ctx.from.indexOf('@')+1).toLowerCase();\\nctx.from_domain = dom;\\n}\\n}\\nif (dom == null) { ctx.suspicion_score = score; return; }\\n// Note: Inline GET requires script.painless.regex.enabled and may not work in all ES versions\\n// This is a placeholder - if it fails, switch to Enrich Processor\\n// For now, skip the lookup to avoid errors\\n// TODO: Implement with Enrich Processor or external enrichment job\\nctx.suspicion_score = score;\\nif (score >= (ctx.containsKey('score_threshold') ? (int)ctx.score_threshold : 40)) ctx.suspicious = true;\\nctx.explanations = reasons;"
      }
    }
  ],
  "on_failure": [
    {
      "set": {
        "field": "_ingest_error",
        "value": "{{_ingest.on_failure_message}}"
      }
    }
  ]
}
